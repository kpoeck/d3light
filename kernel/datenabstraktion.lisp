(in-package :d3l)

(defmethod Regel-Ausfuehren ((ich d3-da-regel-eval))
  (setf (d-gefeuert (dynamic-instance ich)) t)
  ;melde es der si
  (si-irgendwas-empfangen (d3-nummer->objekt (aktionsobjekt ich)) (punkte ich)))

(defmethod REGEL-ZURUECKZIEHEN ((ich d3-da-regel-eval))
  (setf (d-gefeuert (dynamic-instance ich)) nil)
  (si-irgendwas-vergessen (d3-nummer->objekt (aktionsobjekt ich)) (punkte ich))
  )

(defmethod Regel-Ausfuehren ((ich d3-da-regel-alternative))
  (setf (d-gefeuert (dynamic-instance ich)) t)
  (si-irgendwas-empfangen (d3-nummer->objekt (aktionsobjekt ich))(alternative ich))
  )

(defmethod REGEL-ZURUECKZIEHEN ((ich d3-da-regel-alternative))
  (setf (d-gefeuert (dynamic-instance ich)) nil)
  (si-irgendwas-vergessen (d3-nummer->objekt (aktionsobjekt ich)) :kein-wert)
  )

(defmethod Regel-Ausfuehren ((ich d3-da-regel-formel))
  (setf (d-gefeuert (dynamic-instance ich)) t)
  (let ((wert (d3-berechne-formel ich)))
    (si-irgendwas-empfangen (d3-nummer->objekt (aktionsobjekt ich)) wert))
  )

(defmethod REGEL-ZURUECKZIEHEN ((ich d3-da-regel-formel))
  (setf (d-gefeuert (dynamic-instance ich)) nil)
  (si-irgendwas-vergessen (d3-nummer->objekt (aktionsobjekt ich)) :kein-wert)
  )

(defmethod d3-berechne-formel ((ich d3-da-regel-formel))
  (let ((formel (formel ich)))
    (ecase (first formel)
      ($id (GET-ANSWER-VALUE (d3-nummer->objekt (second formel))))
      )
    )
  )

(defmethod si-irgendwas-empfangen ((ich d3-symptominterpretation-punkte) punkte)
  (incf (d-si-punkte (dynamic-instance ich)) punkte)
  (let ((alter-wert (GET-ANSWER-VALUE ich))
        (neuer-wert (schema->nummer (d-si-punkte (dynamic-instance ich)) (possible-values ich)(verechnungsschema ich))))
    (debug-format t ">Eval ~A ~a ~a~%" (d3-objekt->nummer ich) alter-wert neuer-wert)
    (unless (eql alter-wert neuer-wert)
      (SET-ANSWER-VALUE ich neuer-wert)
      (d3-objekt-schliessen ich))
    )
  )

(defmethod gefeuerten-si-bewertungsregeln-vorhanden-p ((ich d3-symptominterpretation)
                                                       )
  (let ((nummer (nummer ich))
        )
    (d3-mit-allen-regeln (objekt)
      (when (and (typep objekt 'D3-DA-REGEL-EVAL)
                 (= nummer (aktionsobjekt objekt))
                 (d-gefeuert (dynamic-instance objekt)))
        (return t)
        )
      )
    )
  )

(defmethod si-irgendwas-vergessen ((ich d3-symptominterpretation-punkte) punkte)
  (decf (d-si-punkte (dynamic-instance ich)) punkte)
  ;problem, entweder kein-wert oder wirklich 0
  (let ((alter-wert (GET-ANSWER-VALUE ich))
        (neuer-wert (cond ((zerop (d-si-punkte (dynamic-instance ich)))
                           (if (gefeuerten-si-bewertungsregeln-vorhanden-p ich)
                             0
                             :kein-wert))
                          (T 
                           (schema->nummer (d-si-punkte (dynamic-instance  ich)) (possible-values ich)(verechnungsschema ich))))))
    (debug-format t ">Eval ~A ~a ~a~%" (d3-objekt->nummer ich) alter-wert neuer-wert)
    (unless (eql alter-wert neuer-wert)
      (SET-ANSWER-VALUE ich neuer-wert)

      (d3-objekt-schliessen ich))
    )
  )

(defmethod si-irgendwas-empfangen ((ich d3-symptominterpretation-oc) wert)
  (SET-ANSWER-VALUE  ich wert)
  (d3-objekt-schliessen ich)
  )

(defmethod si-irgendwas-vergessen ((ich d3-symptominterpretation-oc) egal)
  (declare (ignore egal))
  (SET-ANSWER-VALUE ich :kein-wert)
  (d3-objekt-schliessen ich)
  )

(defmethod si-irgendwas-empfangen ((ich d3-symptominterpretation-num) wert)
  (SET-ANSWER-VALUE  ich wert)
  (d3-objekt-schliessen ich)
  )

(defmethod si-irgendwas-vergessen ((ich d3-symptominterpretation-num) egal)
  (declare (ignore egal))
  (SET-ANSWER-VALUE ich :kein-wert)
  (d3-objekt-schliessen ich)
  )